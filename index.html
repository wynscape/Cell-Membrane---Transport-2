<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Membrane Transport Simulation</title>
    <style>
        /* DESIGN SYSTEM */
        :root {
            --bg: #FFFFFF;
            --text-black: #000000;
            --text-meta: rgba(0, 0, 0, 0.2);
            --lipid-head: #60a5fa; 
            --lipid-tail: #334155; 
            --cytoplasm: #e5e4dc;  /* Darkened intensity (Greige/Dark Beige) */
            --molecule: #9ca3af;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        /* HEADER - CENTRALIZED */
        header {
            padding: 0.8rem 0;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 30;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center horizontally */
            text-align: center;
        }

        .title-line-1 { font-weight: 700; font-size: 1.2rem; color: var(--text-black); line-height: 1.1; }
        .title-line-2 { font-weight: 600; font-size: 1rem; color: var(--text-black); line-height: 1.1; }
        .title-line-3 { font-weight: 600; font-size: 0.6rem; color: var(--text-meta); margin-top: 4px; text-transform: uppercase; letter-spacing: 0.05em; }

        /* CONTROLS - CENTRALIZED & CLOSER */
        .controls {
            position: absolute;
            top: 5rem; /* Moved up relative to previous */
            left: 50%;
            transform: translateX(-50%);
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
        }

        .controls label { font-size: 0.7rem; color: #64748b; font-weight: 600; margin-bottom: 2px; }

        select {
            appearance: none; background-color: #fff; border: 1px solid #cbd5e1;
            color: #334155; padding: 6px 28px 6px 10px; border-radius: 4px;
            font-size: 0.8rem; font-weight: 500; cursor: pointer; outline: none;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%2364748b' stroke-width='2'%3e%3cpath stroke-linecap='round' stroke-linejoin='round' d='M19 9l-7 7-7-7'%3e%3c/path%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 6px center; background-size: 12px;
            text-align: center;
        }

        /* CANVAS */
        #container {
            flex-grow: 1; position: relative; width: 100%; height: 100%;
            cursor: grab; overflow: hidden;
        }
        #container:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        /* FOOTER */
        footer {
            position: absolute; bottom: 8px; width: 100%; text-align: center;
            font-size: 0.7rem; color: #94a3b8; pointer-events: none; z-index: 30;
        }

        .toast {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); border: 1px solid #e2e8f0;
            padding: 6px 12px; border-radius: 20px; font-size: 0.75rem; color: #64748b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); pointer-events: none;
            z-index: 30; transition: opacity 0.5s;
        }
        
        @media print { body { display: none; } }
    </style>
</head>
<body>

<header>
    <div class="title-line-1">Cell Membrane</div>
    <div class="title-line-2">Transport Across Membranes</div>
    <div class="title-line-3">Biology@RI</div>
</header>

<div class="controls">
    <label>Type of movement</label>
    <select id="_mSel">
        <option value="0">Endocytosis - General</option>
        <option value="1">Endocytosis - Phagocytosis</option>
        <option value="2">Endocytosis - Pinocytosis</option>
    </select>
</div>

<div id="container">
    <canvas id="_c"></canvas>
    <div class="toast" id="_tst">Drag the molecule to the membrane</div>
</div>

<footer>All rights reserved</footer>

<script>
/**
 * CELL MEMBRANE LOGIC
 * Updates:
 * - Centralized UI.
 * - Reduced Bilayer Spacing (Heads gap < Head Diameter).
 * - Vesicle fully formed at halfway point.
 * - Strict snapback.
 */
(function(){
    // --- SECURITY ---
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.onkeydown = function(e) {
        if(e.keyCode == 123) return false; 
        if(e.ctrlKey && e.shiftKey && (e.keyCode == 73 || e.keyCode == 74 || e.keyCode == 67)) return false;
        if(e.ctrlKey && e.keyCode == 85) return false;
    };

    const _cvs = document.getElementById('_c');
    const _ctx = _cvs.getContext('2d');
    const _sel = document.getElementById('_mSel');
    const _tst = document.getElementById('_tst');

    // --- CONFIGURATION ---
    let _w, _h, _t = 0;
    
    // SCALE SETTINGS
    const _HEAD_R = 3.5;       
    const _HEAD_DIA = 7;
    const _TAIL_H = 12; // Shortened tails slightly to maintain proportion
    // Constraint: Gap between upper tails and lower tails must be tight
    // Space between Upper Head Center and Lower Head Center = Thickness
    // User wants gap between LAYERS < Blue Circle Diameter.
    const _GAP = 2; // Very tight gap (tails almost touch)
    const _THICKNESS = (_TAIL_H * 2) + _GAP; // Total thickness approx 26px
    const _SPACING = 8;        

    // MEMBRANE POSITION
    // Move up by 30% closer to dropdown. 
    // Dropdown is at ~80px. Membrane was at 0.35h. Let's move to 0.25h.
    const _MEM_Y_FACTOR = 0.25; 

    // MOLECULE (Enlarged)
    const _mol = { 
        x: 0, y: 0, 
        r: 27, 
        drag: false, 
        startY: 0 
    };
    
    // COLORS
    const C_HEAD = '#60a5fa';
    const C_TAIL = '#334155'; 
    const C_MOL = '#9ca3af';
    const C_CYTO = '#e5e4dc'; // Darker Beige

    function _init() {
        _w = _cvs.width = window.innerWidth;
        _h = _cvs.height = window.innerHeight;
        // Start just above membrane
        const memY = _h * _MEM_Y_FACTOR;
        _mol.startY = memY - 80; 
        _reset();
    }

    function _reset() {
        _mol.x = _w / 2;
        _mol.y = _mol.startY;
        _mol.drag = false;
        _tst.style.opacity = 1;
    }

    // --- INPUT HANDLERS ---
    function _getPos(e) {
        const r = _cvs.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        return { x: t.clientX - r.left, y: t.clientY - r.top };
    }

    function _down(e) {
        const p = _getPos(e);
        if (Math.hypot(p.x - _mol.x, p.y - _mol.y) < 60) {
            _mol.drag = true;
            _tst.style.opacity = 0;
        }
    }

    function _move(e) {
        if (!_mol.drag) return;
        e.preventDefault();
        const p = _getPos(e);
        _mol.x = p.x;
        const limit = _h - 40; 
        _mol.y = Math.min(limit, p.y);
    }

    function _up() {
        // Strict Reset
        _mol.drag = false;
        _snapBack();
    }

    function _snapBack() {
        const anim = () => {
            if (_mol.drag) return;
            _mol.x += (_w/2 - _mol.x) * 0.15;
            _mol.y += (_mol.startY - _mol.y) * 0.15;
            if (Math.abs(_mol.y - _mol.startY) > 0.5) {
                requestAnimationFrame(anim);
            }
        };
        anim();
    }

    _cvs.addEventListener('mousedown', _down);
    window.addEventListener('mousemove', _move);
    window.addEventListener('mouseup', _up);
    _cvs.addEventListener('touchstart', _down, {passive:false});
    window.addEventListener('touchmove', _move, {passive:false});
    window.addEventListener('touchend', _up);
    _sel.addEventListener('change', _reset);
    window.addEventListener('resize', _init);

    // --- GEOMETRY & RENDERING ---
    function _drawLipid(ctx, x, y, angle, isUpper) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        const dir = isUpper ? 1 : -1;
        
        // Tails
        ctx.strokeStyle = C_TAIL;
        ctx.lineWidth = 1.5; 
        ctx.beginPath();
        ctx.moveTo(-1.5, 0); ctx.lineTo(-1.5, dir * _TAIL_H);
        ctx.moveTo(1.5, 0); ctx.lineTo(1.5, dir * _TAIL_H);
        ctx.stroke();

        // Head
        ctx.fillStyle = C_HEAD;
        ctx.beginPath();
        ctx.arc(0, 0, _HEAD_R, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }

    function _loop() {
        _t += 0.05;
        _ctx.clearRect(0,0,_w,_h);

        const memY = _h * _MEM_Y_FACTOR;
        const footerY = _h - 35;
        
        // --- VESICLE FORMATION LOGIC ---
        // Requirement: Fully formed at HALFWAY distance.
        const distanceTotal = footerY - memY;
        const formationPoint = memY + (distanceTotal * 0.5); // Halfway
        
        // Current Depth
        const currentY = _mol.y;
        
        // Calculate Neck Width based on progress to Halfway point
        // 0% progress = full width (approx 80)
        // 100% progress (at halfway) = 0 width (pinched)
        
        let neckWidth = 80;
        let isDetached = false;

        if (currentY > memY) {
            const progress = (currentY - memY) / (formationPoint - memY);
            if (progress >= 1) {
                neckWidth = 0;
                isDetached = true;
            } else {
                neckWidth = 80 * (1 - progress);
            }
        }

        // --- GENERATE PATHS ---
        const points = [];
        const vesiclePoints = []; // For detached vesicle
        const step = _SPACING;

        // 1. MAIN MEMBRANE PATH
        for(let x = -20; x <= _w + 20; x += step) {
            let y = memY + Math.sin(x * 0.03 + _t) * 4;
            
            if (!isDetached) {
                // Invagination Logic (Attached)
                const dx = x - _mol.x;
                const pitWidth = neckWidth + (_mol.r * 1.5);
                
                if (currentY > memY && Math.abs(dx) < pitWidth) {
                    const depth = currentY - memY;
                    // Shape function
                    const shape = Math.exp(-Math.pow(dx / (20 + neckWidth/2), 2));
                    y += shape * depth;
                }
            }
            points.push({x, y});
        }

        // 2. DETACHED VESICLE PATH (If applicable)
        if (isDetached) {
            const vR = _mol.r + _THICKNESS/2 + 5; // Radius of vesicle center line
            const circumference = 2 * Math.PI * vR;
            const numV = Math.floor(circumference / _SPACING);
            
            for(let i=0; i<numV; i++) {
                const ang = (i/numV) * Math.PI * 2 + _t * 0.1;
                const vx = _mol.x + Math.cos(ang) * vR;
                const vy = _mol.y + Math.sin(ang) * vR;
                // Normal points OUT from center
                const nx = Math.cos(ang);
                const ny = Math.sin(ang);
                vesiclePoints.push({x:vx, y:vy, ang: ang + Math.PI/2});
            }
        }

        // --- DRAWING ---

        // A. CYTOPLASM FILL
        _ctx.fillStyle = C_CYTO;
        _ctx.beginPath();
        _ctx.moveTo(0, footerY);
        
        // Trace Main Membrane Bottom
        for(let i=1; i<points.length-1; i++) {
            const p = points[i];
            const prev = points[i-1];
            const next = points[i+1];
            const tan = Math.atan2(next.y - prev.y, next.x - prev.x);
            const nx = -Math.sin(tan);
            const ny = Math.cos(tan);
            const by = p.y + (ny * _THICKNESS/2);
            if(i===1) _ctx.lineTo(0, by);
            _ctx.lineTo(p.x + (nx*_THICKNESS/2), by);
        }
        _ctx.lineTo(_w, footerY);
        _ctx.closePath();
        _ctx.fill();

        // Label
        _ctx.fillStyle = "rgba(0,0,0,0.4)";
        _ctx.font = "bold 16px sans-serif";
        _ctx.textAlign = "left";
        _ctx.fillText("CYTOPLASM", 20, footerY - 80);

        // B. LIPIDS (Main Membrane)
        for(let i=1; i<points.length-1; i++) {
            const p = points[i];
            const prev = points[i-1];
            const next = points[i+1];
            const tan = Math.atan2(next.y - prev.y, next.x - prev.x);
            const nx = -Math.sin(tan);
            const ny = Math.cos(tan);

            const tx = p.x + (nx * -_THICKNESS/2);
            const ty = p.y + (ny * -_THICKNESS/2);
            const bx = p.x + (nx * _THICKNESS/2);
            const by = p.y + (ny * _THICKNESS/2);

            _drawLipid(_ctx, tx, ty, tan, true);
            _drawLipid(_ctx, bx, by, tan, false);
        }

        // C. LIPIDS (Vesicle - if detached)
        if (isDetached) {
            for(let p of vesiclePoints) {
                // Inner (was Upper) -> Heads point IN (towards molecule)
                // We rotated angle +90. Normal points OUT.
                // To point heads IN: translate -Thickness/2
                
                const nx = Math.cos(p.ang - Math.PI/2); 
                const ny = Math.sin(p.ang - Math.PI/2);
                
                // Note: In circle geometry logic above:
                // ang is angle from center. 
                // We want Inner Layer (heads touch fluid) and Outer Layer (heads touch cytoplasm)
                
                // Inner Layer Position
                const ix = p.x + (nx * -_THICKNESS/2);
                const iy = p.y + (ny * -_THICKNESS/2);
                
                // Outer Layer Position
                const ox = p.x + (nx * _THICKNESS/2);
                const oy = p.y + (ny * _THICKNESS/2);
                
                // Draw Inner (Heads point IN towards center)
                // _drawLipid rotation logic: 0 = straight up.
                // We need to rotate so tails point OUT.
                _drawLipid(_ctx, ix, iy, p.ang, false); // false = heads down (relative to rotation)
                
                // Draw Outer (Heads point OUT towards cytoplasm)
                _drawLipid(_ctx, ox, oy, p.ang, true); // true = heads up
            }
        }

        // D. MOLECULE
        _ctx.fillStyle = C_MOL;
        _ctx.beginPath();
        _ctx.arc(_mol.x, _mol.y, _mol.r, 0, Math.PI*2);
        _ctx.fill();

        requestAnimationFrame(_loop);
    }

    _init();
    _loop();

})();
</script>
</body>
</html>
