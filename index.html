code
Html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Membrane Transport Simulation</title>
    <style>
        /* DESIGN SYSTEM */
        :root {
            --bg: #FFFFFF;
            --text-black: #000000;
            --text-meta: rgba(0, 0, 0, 0.2);
            --lipid-head: #60a5fa; 
            --lipid-tail: #334155; 
            --cytoplasm: #fdfbf7;  
            --molecule: #9ca3af;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        /* HEADER */
        header {
            padding: 0.8rem 1.5rem;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 30;
            pointer-events: none;
        }

        .title-line-1 { font-weight: 700; font-size: 1.2rem; color: var(--text-black); line-height: 1.1; }
        .title-line-2 { font-weight: 600; font-size: 1rem; color: var(--text-black); line-height: 1.1; }
        .title-line-3 { font-weight: 600; font-size: 0.6rem; color: var(--text-meta); margin-top: 4px; text-transform: uppercase; letter-spacing: 0.05em; }

        /* CONTROLS */
        .controls {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .controls label { font-size: 0.7rem; color: #64748b; font-weight: 600; margin-right: 2px; }

        select {
            appearance: none; background-color: #fff; border: 1px solid #cbd5e1;
            color: #334155; padding: 6px 28px 6px 10px; border-radius: 4px;
            font-size: 0.8rem; font-weight: 500; cursor: pointer; outline: none;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%2364748b' stroke-width='2'%3e%3cpath stroke-linecap='round' stroke-linejoin='round' d='M19 9l-7 7-7-7'%3e%3c/path%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 6px center; background-size: 12px;
        }

        /* CANVAS */
        #container {
            flex-grow: 1; position: relative; width: 100%; height: 100%;
            cursor: grab; overflow: hidden;
        }
        #container:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        /* FOOTER */
        footer {
            position: absolute; bottom: 8px; width: 100%; text-align: center;
            font-size: 0.7rem; color: #94a3b8; pointer-events: none; z-index: 30;
        }

        .toast {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); border: 1px solid #e2e8f0;
            padding: 6px 12px; border-radius: 20px; font-size: 0.75rem; color: #64748b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); pointer-events: none;
            z-index: 30; transition: opacity 0.5s;
        }
        
        @media print { body { display: none; } }
    </style>
</head>
<body>

<header>
    <div class="title-line-1">Cell Membrane</div>
    <div class="title-line-2">Transport Across Membranes</div>
    <div class="title-line-3">Biology@RI</div>
</header>

<div class="controls">
    <label>Type of movement</label>
    <select id="_mSel">
        <option value="0">Endocytosis - General</option>
        <option value="1">Endocytosis - Phagocytosis</option>
        <option value="2">Endocytosis - Pinocytosis</option>
    </select>
</div>

<div id="container">
    <canvas id="_c"></canvas>
    <div class="toast" id="_tst">Drag the molecule to the membrane</div>
</div>

<footer>&copy; All rights reserved</footer>

<script>
/**
 * CELL MEMBRANE LOGIC
 * Features: 
 * - 50% Larger Molecule.
 * - Topological transformation (Upper->Inner, Lower->Outer).
 * - Strict Reset (Elastic Snapback).
 */
(function(){
    // --- SECURITY ---
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.onkeydown = function(e) {
        if(e.keyCode == 123) return false; 
        if(e.ctrlKey && e.shiftKey && (e.keyCode == 73 || e.keyCode == 74 || e.keyCode == 67)) return false;
        if(e.ctrlKey && e.keyCode == 85) return false;
    };

    const _cvs = document.getElementById('_c');
    const _ctx = _cvs.getContext('2d');
    const _sel = document.getElementById('_mSel');
    const _tst = document.getElementById('_tst');

    // --- CONFIGURATION ---
    let _w, _h, _t = 0;
    
    // SCALE SETTINGS
    const _HEAD_R = 3.5;       
    const _TAIL_H = 15;        
    const _GAP = 12;           
    const _SPACING = 8;        
    const _THICKNESS = (_TAIL_H * 2) + _GAP; 
    const _MEM_Y_FACTOR = 0.35; 

    // MOLECULE (Enlarged 50% from 18 -> 27)
    const _mol = { 
        x: 0, y: 0, 
        r: 27, 
        drag: false, 
        startY: 0 
    };
    
    // COLORS
    const C_HEAD = '#60a5fa';
    const C_TAIL = '#334155'; 
    const C_MOL = '#9ca3af';
    const C_CYTO = '#fdfbf7';

    function _init() {
        _w = _cvs.width = window.innerWidth;
        _h = _cvs.height = window.innerHeight;
        // Start just above membrane
        const memY = _h * _MEM_Y_FACTOR;
        _mol.startY = memY - 80; 
        _reset();
    }

    function _reset() {
        _mol.x = _w / 2;
        _mol.y = _mol.startY;
        _mol.drag = false;
        _tst.style.opacity = 1;
    }

    // --- INPUT HANDLERS ---
    function _getPos(e) {
        const r = _cvs.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        return { x: t.clientX - r.left, y: t.clientY - r.top };
    }

    function _down(e) {
        const p = _getPos(e);
        if (Math.hypot(p.x - _mol.x, p.y - _mol.y) < 60) {
            _mol.drag = true;
            _tst.style.opacity = 0;
        }
    }

    function _move(e) {
        if (!_mol.drag) return;
        e.preventDefault();
        const p = _getPos(e);
        _mol.x = p.x;
        // Limit movement above footer
        const limit = _h - 40; 
        _mol.y = Math.min(limit, p.y);
    }

    function _up() {
        // STRICT RESET RULE:
        // Once finger doesn't touch, molecule MUST return to original position.
        _mol.drag = false;
        _snapBack();
    }

    function _snapBack() {
        // Elastic snapback animation
        const anim = () => {
            if (_mol.drag) return; // Stop if grabbed again
            
            // Smooth easing (Lerp)
            _mol.x += (_w/2 - _mol.x) * 0.15;
            _mol.y += (_mol.startY - _mol.y) * 0.15;
            
            // Stop condition
            if (Math.abs(_mol.y - _mol.startY) > 0.5) {
                requestAnimationFrame(anim);
            }
        };
        anim();
    }

    _cvs.addEventListener('mousedown', _down);
    window.addEventListener('mousemove', _move);
    window.addEventListener('mouseup', _up);
    _cvs.addEventListener('touchstart', _down, {passive:false});
    window.addEventListener('touchmove', _move, {passive:false});
    window.addEventListener('touchend', _up);
    _sel.addEventListener('change', _reset);
    window.addEventListener('resize', _init);

    // --- GEOMETRY & RENDERING ---
    
    // Draw a single lipid
    function _drawLipid(ctx, x, y, angle, isUpper) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        const dir = isUpper ? 1 : -1;
        
        // Tails
        ctx.strokeStyle = C_TAIL;
        ctx.lineWidth = 1.5; 
        ctx.beginPath();
        ctx.moveTo(-1.5, 0); ctx.lineTo(-1.5, dir * _TAIL_H);
        ctx.moveTo(1.5, 0); ctx.lineTo(1.5, dir * _TAIL_H);
        ctx.stroke();

        // Head
        ctx.fillStyle = C_HEAD;
        ctx.beginPath();
        ctx.arc(0, 0, _HEAD_R, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }

    // Main Physics & Drawing Loop
    function _loop() {
        _t += 0.05;
        _ctx.clearRect(0,0,_w,_h);

        // --- 1. CALCULATE MEMBRANE GEOMETRY ---
        // Instead of a simple function, we generate a path based on molecule depth.
        // This ensures the "wrapping" effect.
        
        const baseY = _h * _MEM_Y_FACTOR;
        const depth = Math.max(0, _mol.y - (baseY - _mol.r));
        const interactionRadius = 80; // How wide the membrane is pulled
        
        // As depth increases, the "neck" (opening width) decreases
        // At depth 0, width is interactionRadius. 
        // At high depth, width approaches 0 (pinch).
        // Smooth transition:
        let neckFactor = Math.max(0, 1 - (depth / 200)); 
        let neckWidth = interactionRadius * neckFactor;
        if(neckWidth < 10 && depth > 50) neckWidth = 0; // Snap shut visually

        // Points generation
        // We use discrete steps to build the membrane path
        const points = [];
        const step = _SPACING; // Keep spacing constant
        
        // Loop X from 0 to Width
        for(let x = -20; x <= _w + 20; x += step) {
            let y = baseY + Math.sin(x * 0.03 + _t) * 4;
            let ang = 0;
            
            // Interaction Logic
            const dx = x - _mol.x;
            
            // If we are far from molecule, simple sine wave.
            // If near, we calculate the "wrap" position.
            
            // Influence based on current Neck Width
            // We use a blend.
            
            // This logic bends the line around the circle
            if (depth > 0 && Math.abs(dx) < interactionRadius * 1.5) {
                // Determine point on the molecule surface
                // Current wrap amount (0 to 1)
                // If depth is high, we wrap almost 360 degrees
                
                // Gaussian displacement is easier for smooth "soap bubble" stretching
                // Modified Gaussian: Width narrows as Depth increases
                
                // Calculate pit shape
                const pitWidth = neckWidth + (_mol.r * 1.5); // Effective width of the deformation
                if (Math.abs(dx) < pitWidth) {
                    // Normalize X (-1 to 1 within pit)
                    const nx = dx / pitWidth;
                    // Shape function: Smooth drop
                    const shape = Math.exp(-Math.pow(dx / (30 + neckWidth/2), 2));
                    
                    // Add depth
                    y += shape * depth;
                    
                    // SUCK IN EFFECT: As we go deeper, X coordinates pull toward center
                    // This creates the "neck" narrowing effect visually
                    if (depth > 50) {
                        const suckFactor = (depth - 50) / 200;
                        const suckAmount = (x - _mol.x) * suckFactor * 0.5;
                         // Apply shift visually only (simulated x) or keep x constant?
                         // Keeping x constant stretches lipids. 
                         // To simulate "flow", we just modify y here for visual simplicity 
                         // while relying on density from the loop step.
                    }
                }
            }
            
            // Calculate angle for this point (Approximate normal)
            // We need next point to get true normal
            points.push({x:x, y:y});
        }
        
        // --- 2. DRAW CYTOPLASM (Beige) ---
        // Fill from bottom lipids down to footer
        const footerY = _h - 35; // Stop above rights reserved
        
        _ctx.fillStyle = C_CYTO;
        _ctx.beginPath();
        _ctx.moveTo(0, footerY);
        
        // Iterate points to trace bottom of membrane
        // Calculate normals on the fly
        for(let i=1; i<points.length-1; i++) {
            const p = points[i];
            const prev = points[i-1];
            const next = points[i+1];
            
            // Normal calculation
            const tan = Math.atan2(next.y - prev.y, next.x - prev.x);
            const nx = -Math.sin(tan);
            const ny = Math.cos(tan);
            
            // Bottom Head Position
            const bx = p.x + (nx * _THICKNESS/2);
            const by = p.y + (ny * _THICKNESS/2);
            
            if(i===1) _ctx.lineTo(0, by);
            _ctx.lineTo(bx, by);
        }
        _ctx.lineTo(_w, footerY);
        _ctx.closePath();
        _ctx.fill();

        // Label
        _ctx.fillStyle = "rgba(0,0,0,0.4)";
        _ctx.font = "bold 16px sans-serif";
        _ctx.textAlign = "left";
        _ctx.fillText("CYTOPLASM", 20, footerY - 80);

        // --- 3. DRAW MEMBRANE (LIPIDS) ---
        for(let i=1; i<points.length-1; i++) {
            const p = points[i];
            const prev = points[i-1];
            const next = points[i+1];
            
            const tan = Math.atan2(next.y - prev.y, next.x - prev.x);
            const nx = -Math.sin(tan);
            const ny = Math.cos(tan);

            // Upper Leaflet (Becomes Inner Layer)
            // Position: Center - Normal*Thickness/2
            const tx = p.x + (nx * -_THICKNESS/2);
            const ty = p.y + (ny * -_THICKNESS/2);
            
            // Lower Leaflet (Becomes Outer Layer)
            // Position: Center + Normal*Thickness/2
            const bx = p.x + (nx * _THICKNESS/2);
            const by = p.y + (ny * _THICKNESS/2);

            // Draw
            // Upper: Heads point UP relative to curve (which means IN towards center of curvature if concave)
            _drawLipid(_ctx, tx, ty, tan, true);
            
            // Lower: Heads point DOWN relative to curve (OUT away from center of curvature)
            _drawLipid(_ctx, bx, by, tan, false);
        }

        // --- 4. DRAW MOLECULE ---
        _ctx.fillStyle = C_MOL;
        _ctx.beginPath();
        _ctx.arc(_mol.x, _mol.y, _mol.r, 0, Math.PI*2);
        _ctx.fill();

        requestAnimationFrame(_loop);
    }

    _init();
    _loop();

})();
</script>
</body>
</html>
